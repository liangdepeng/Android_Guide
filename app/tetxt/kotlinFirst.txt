Kotlin-kotlin-android-extension被抛弃了
1.控件错误导入
2.局限性
只能在Kotlin代码使用，而Java是没法使用的，那么Java就得用另外一套方式，对于Kotlin、Java共存的项目就会增加维护性。

1. 简化空对象的处理(防止空指针)
2. 属性访问,代替Get/Set方法
3.扩展函数
4.对象属性调用简化。let/apply/with
5.协程coroutines

suspend协程挂起原理
在编译期，将suspend标记的方法转化成接口回调的方式，本质上还是基于回调实现的

协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，
但是协程挂起时不需要阻塞线程，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，
一个线程中可以创建任意个协程。

kotlin协程本质上是对线程池的封装
协程通过将线程切换的复杂性封装入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。

 协程最主要的优点还不在于减少代码,而在于使调用逻辑简化,使得我们不必使用AsyncTask或者RxJava这样复杂的方案.
协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起
时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建
任意个协程。协程很重要的一点就是当它挂起的时候，它不会阻塞其他线程。协程底层库也是异步处理阻塞任务，但是这些复杂
的操作被底层库封装起来，协程代码的程序流是顺序的，不再需要一堆的回调函数，就像同步代码一样，也便于理解、调试和开发。
它是可控的，线程的执行和结束是由操作系统调度的，而协程可以手动控制它的执行和结束。

runBlocking 阻塞当前线程
launch不会阻断主线程。
 val job = GlobalScope.launch {
            delay(6000)
            Log.e(TAG, "协程执行结束 -- 线程id：${Thread.currentThread().id}")
}
从方法定义中可以看出，launch() 是CoroutineScope的一个扩展函数，CoroutineScope简单来说就是协程的作用范围。
launch方法有三个参数：1.协程下上文；2.协程启动模式；3.协程体：block是一个带接收者的函数字面量，
接收者是CoroutineScope

1.协程下上文
上下文可以有很多作用，包括携带参数，拦截协程执行等等，多数情况下我们不需要自己去实现上下文，只需要使用现成的就好。
上下文有一个重要的作用就是线程切换，Kotlin协程使用调度器来确定哪些线程用于协程执行，Kotlin提供了调度器给我们使用：
Dispatchers.Main：使用这个调度器在 Android 主线程上运行一个协程。可以用来更新UI 。在UI线程中执行
Dispatchers.IO：这个调度器被优化在主线程之外执行磁盘或网络 I/O。在线程池中执行
Dispatchers.Default：这个调度器经过优化，可以在主线程之外执行 cpu 密集型的工作。例如对列表进行排序和解析 JSON。在线程池中执行。
Dispatchers.Unconfined：在调用的线程直接执行。

协程体是一个用suspend关键字修饰的一个无参，无返回值的函数类型。
被suspend修饰的函数称为挂起函数,与之对应的是关键字resume（恢复），
注意：挂起函数只能在协程中和其他挂起函数中调用，不能在其他地方使用。
suspend函数会将整个协程挂起，而不仅仅是这个suspend函数，也就是说一个协程中有多个挂起函数时，它们是顺序执行的

async
async跟launch的用法基本一样，区别在于：async的返回值是Deferred，将最后一个封装成了该对象。
async可以支持并发，此时一般都跟await一起使用






